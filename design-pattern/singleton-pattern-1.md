# Singleton Pattern

#### Lazy pattern, single thread

```java
class Singleton {

    // reference to an instance of self class
    private static Singleton instance;
    
    // private constructor
    private Singleton() {
    }
    
    // provide an accessor to obtain instance
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
    }
}
```

#### Hungry pattern, thread safe

```java
class Singleton {

    // reference to an instance of self class, but waste memory 
    private static final Singleton instance = new Singleton();
    
    private Singleton() {
    }
    
    public static Singleton getInstance() {
        return instance;
    }
    
}
```

#### Lazy pattern, thread safe

```java
class Singleton {
    private static Singleton instance;
    
    private Singleton() {
    }
    
    // Add lock, but expensive due to `synchronized` overhead
    public static synchronized Singleton getInstance() {
        if (instance  == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

#### Double Checking Locking (DCL)

Reduce overhead of acquiring a lock by testing the lock criterion before acquiring it.

```java
class Singleton {
    private static Singleton instance;
    
    private Singleton() {
    }
    
    // protect when first created, non-protected when read
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

DCL means only adding lock when it's first time trying to create instance (when is null). If found the instance is already created, no need to enter the critical section which is protected by lock. In this way, Singleton class is allowed concurrently read, but only one thread can write(create) instance at a time (when is the first time the instance is created).

Therefore, compared to '_Hungry pattern, thread safe_', which directly add a lock (sychronized) to the whole `getInstance()` method, DCL has higher efficiency.

Here are steps of DCL:

* Check that the variable is initialized (without obtaining the lock). If it is initialized, return it immediately.
* Obtain the lock.
* Double-check whether the variable has already been initialized: if another thread acquired the lock first, it may have already done the initialization. If so, return the initialized variable.
* Otherwise, initialize and return the variable.

#### DCL: Further discuss

Volatile (_the volatile modifier guarantees that any thread that reads a field will see the most recently written value_, avoid rearrangement of instructions).  Also, volatile is expensive ([link](https://stackoverflow.com/questions/1090311/are-volatile-variable-reads-as-fast-as-normal-reads)). To make DCL work correctly, declare instance volatile:

```java
private static volatile Singleton instance;
```

Then, consider the discussion from wiki:

> Intuitively, this algorithm(DCL) seems like an efficient solution to the problem. However, this technique has many subtle problems and should usually be avoided. For example, consider the following sequence of events:
>
> 1. Thread _A_ notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
> 2. Due to the semantics of some programming languages, the code generated by the compiler is allowed to update the shared variable to point to a **partially constructed object** before _A_ has finished performing the initialization. For example, in Java if a call to a constructor has been inlined then the shared variable may immediately be updated once the storage has been allocated but before the inlined constructor initializes the object.[\[6\]](https://en.wikipedia.org/wiki/Double-checked\_locking#cite\_note-IBM-6)
> 3. Thread _B_ notices that the shared variable has been initialized (or so it appears), and returns its value. Because thread _B_ believes the value is already initialized, it does not acquire the lock. If _B_ uses the object before all of the initialization done by _A_ is seen by _B_ (either because _A_ has not finished initializing it or because some of the initialized values in the object have not yet percolated to the memory _B_ uses ([cache coherence](https://en.wikipedia.org/wiki/Cache\_coherence))), the program will likely crash.
>
> One of the dangers of using double-checked locking in [J2SE 1.4](https://en.wikipedia.org/wiki/Java\_Platform,\_Standard\_Edition) (and earlier versions) is that it will often appear to work: it is not easy to distinguish between a correct [implementation](https://en.wikipedia.org/wiki/Implementation) of the technique and one that has subtle problems. Depending on the [compiler](https://en.wikipedia.org/wiki/Compiler), the interleaving of threads by the [scheduler](https://en.wikipedia.org/wiki/Scheduling\_\(computing\)) and the nature of other [concurrent system activity](https://en.wikipedia.org/wiki/Concurrency\_\(computer\_science\)), failures resulting from an incorrect implementation of double-checked locking may only occur intermittently. Reproducing the failures can be difficult.
>
> As of [J2SE 5.0](https://en.wikipedia.org/wiki/Java\_Platform,\_Standard\_Edition), this problem has been fixed. The [volatile](https://en.wikipedia.org/wiki/Volatile\_variable) keyword now ensures that multiple threads handle the singleton instance correctly.&#x20;

```java
class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {
    }
    
    public static Singleton getInstance() {
        Singleton localInstance = instance;
        if (localInstance == null) {
            synchronized(Singleton.class) {
                if (localInstance == null) {
                    instance = localInstance = new Singleton();
                }
            }
        }
        return localInstance;
    }
}
```

> Note the local variable "localInstance", which seems unnecessary. The effect of this is that in cases where instance is already initialized (i.e., most of the time), the volatile field is only accessed once (due to `return localInstance;` instead of `return instance;`), which can improve the method's overall performance by as much as 40 percent.[\[7\]](https://en.wikipedia.org/wiki/Double-checked\_locking#cite\_note-7)

### References

* [Double-checked locking](https://en.wikipedia.org/wiki/Double-checked\_locking#Usage\_in\_Java)
* [Java DCL Issue](https://refactoring.guru/design-patterns/singleton/java/example#example-2)
* [Coding interview, Singleton pattern ](https://github.com/char-1ee/CodingInterviewChinese2/blob/main/java/2\_Singleton.java)
